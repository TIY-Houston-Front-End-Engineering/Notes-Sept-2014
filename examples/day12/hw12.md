> This is to be done as a group assignment. We may have one group of 3 students.

# Part I

Observe the setup of this code as a nice explanation of how some Array methods work, then fix the code at the end.

```js
// set up arrays
var numbers = [1,12,4,18,9,7,11,3,101,5,6];
var strings = ['this','is','a','collection','of','words'];

// array.reduce - find largest number
var largestValue = numbers.reduce(function(x,y){ });
console.log('largest number: ' + largestValue);

// array.reduce - find longest string
var longest = strings.reduce(function(x,y){ });
console.log('longest word: ' + longest);

// array.filter - find even numbers
var evens = numbers.filter(function(x){ });
console.log('even numbers: ' + evens);

// array.filter - find odd numbers
var odds = numbers.filter(function(x){ return x%2 !== 0})
console.log('odds numbers: ' + odds);

// array .filter - find words that contain 'is'
var wordsWithIs = strings.filter(function(x){ })
console.log('words containing is: ' + wordsWithIs);

// array.every - assert all numbers are divisible by three
var divisibleByThree = evens.every(function(n){ });
console.log('All numbers divisible by three: ' + divisibleByThree);

var customers = [
    { firstname : 'Joe', lastname : 'Blogs'},
    { firstname : 'John', lastname : 'Smith'},
    { firstname : 'Dave', lastname : 'Jones'},
    { firstname : 'Jack', lastname : 'White'}
];

console.log(customers);

// FIX THIS STUFF :)
// find all customers whose firstname starts with 'J',
// map those people to objects that looks like { name : c.firstname + ' ' + c.lastname }
// then sort alphabetically

var projections = customers
    .filter(function(c){ /* ... */ })
    .map(function(c){  /* ... */ })
    .sort(sortByName);

function sortByName(c1, c2) {
    "use strict";
    //...
}

console.log(projections);
```

# Part II

One of the most useful exercises I've ever done as a programmer is the following:

1. Write your own forEach function. It takes the array and the function (referred to as a callback) as arguments:
    ```js
    function forEach(list, callback) { /* Do stuff */ }
    ```

2. Write your own map, reduce, and filter that use your custom forEach to do their work.

3. Write a function called pluck that extracts a list of property names:
    ```js
    function pluck(list, propertyName) { /* Do stuff*/ }

    var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
    pluck(stooges, 'name');
    // => ["moe", "larry", "curly"]
    ```

4. Write a function called reject that returns the values in list without the elements that the truth test (predicate) passes. The opposite of filter.
    ```js
    function reject(list, predicate) { /* Do stuff */ }

    var odds = reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
    //=> [1, 3, 5]
    ```

5. Write a function called find that looks through each value in the list, returning the first one that passes a truth test (predicate), or undefined if no value passes the test. The function returns as soon as it finds an acceptable element, and doesn't traverse the entire list.
    ```js
    function find(list, predicate) { /* Do stuff */ }

    var even = find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
    //=> 2
    ```

6. Write a function called where that looks through each value in the list, returning an array of all the values that contain all of the key-value pairs listed in properties.
    ```js
    function where(list, properties) { /* Do stuff */ }

    where(listOfPlays, {author: "Shakespeare", year: 1611});
    // => [{title: "Cymbeline", author: "Shakespeare", year: 1611},
    //     {title: "The Tempest", author: "Shakespeare", year: 1611}]
    ```